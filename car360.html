<!DOCTYPE html>
<html lang="en">
<head>
<title>three.js webgl - geometry - cube</title>
<meta charset="utf-8">
<style>
body {
margin: 0px;
        background-color: #000000;
overflow: hidden;
}

body h1{
  color:#363F45;
  font-family:Arial, Helvetica, sans-serif;
  font-size:3em;
}

</style>
</head>
<body>


<script src="js/three.min.js"></script>
<script src="js/jquery-1.7.1.min.js"></script>
<script src="js/dat.gui.min.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/Detector.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">

varying vec3 v_texCoord;

uniform float drawPlane;

void main() {

   gl_Position = vec4( position, 1.0 );

  v_texCoord = position;


}

</script>

<script id="fragmentShader" type="x-shader/x-fragment">

uniform float frontValid;
uniform float  rearValid;
uniform float  leftValid;
uniform float rightValid;


uniform vec2 inputResolution;
uniform vec2 outputResolution;

uniform vec3 targetCameraPosition;
uniform vec3 targetCameraPoint;
uniform float targetCameraFocusLen;

uniform vec3 worldPlanePoint;
uniform vec3 worldPlaneVector;

uniform sampler2D textureSource;

uniform sampler2D textureWorldPointX;
uniform sampler2D textureWorldPointY;
uniform sampler2D textureWorldPointZ;

uniform sampler2D textureTT;

uniform float   frontMaxRadius;
uniform float    rearMaxRadius;
uniform float    leftMaxRadius;
uniform float   rightMaxRadius;

uniform vec2   frontCetroid;
uniform vec2    rearCetroid;
uniform vec2    leftCetroid;
uniform vec2   rightCetroid;

uniform vec4 frontMatrixVec0;
uniform vec4 frontMatrixVec1;
uniform vec4 frontMatrixVec2;
uniform vec4  rearMatrixVec0;
uniform vec4  rearMatrixVec1;
uniform vec4  rearMatrixVec2;
uniform vec4  leftMatrixVec0;
uniform vec4  leftMatrixVec1;
uniform vec4  leftMatrixVec2;
uniform vec4 rightMatrixVec0;
uniform vec4 rightMatrixVec1;
uniform vec4 rightMatrixVec2;

uniform float drawPlane;

varying vec3 v_texCoord;

const int MAXPOINTCOUNT=4;
const float EPS=1e-0;

const vec4 BLACKCOLOR=vec4(vec3(0.),1.);
const vec4 WHITECOLOR=vec4(vec3(1.),1.);


struct CameraMatrix
{
  mat4 m;
  mat4 mt;
};

struct Ray
{
  vec3 point; // start point of the ray 
  vec3 direct; // the direct of the ray 
};

struct Plane
{
  vec3 point; // point on the plane
  vec3 normal; // normal vector of the plane
};

struct IntersectPoints
{
  int  count; // count of the points
  vec3 points0;
  vec3 points1;
  vec3 points2;
  vec3 points3;
};

struct ImageCoordinate
{
  bool valid; //this value indicates whether this image has pix for this position
  vec2 imageCoord;
};

IntersectPoints getIntersectRayPlane( Ray ray, Plane plane)
{
  IntersectPoints intersectPoints;
  intersectPoints.count=0;

  float t=(dot(plane.point, plane.normal)-dot(ray.point, plane.normal))/dot(ray.direct,plane.normal);
  if(t>=0.)
  {
    intersectPoints.count=1;
    intersectPoints.points0=ray.point+ray.direct*t;
  }
  return intersectPoints;
}

mat3 getRotateMatrixByAxe(mat3 m0, mat3 m1)
{
  vec3 m00 = vec3(m0[0].x, m0[1].x, m0[2].x);
  vec3 m01 = vec3(m0[0].y, m0[1].y, m0[2].y);
  vec3 m02 = vec3(m0[0].z, m0[1].z, m0[2].z);

  vec3 m10 = m1[0];
  vec3 m11 = m1[1];
  vec3 m12 = m1[2];

  mat3 R = mat3( 
                dot( m00, m10 ), dot( m00, m11 ), dot( m00, m12 ), 
                dot( m01, m10 ), dot( m01, m11 ), dot( m01, m12 ), 
                dot( m02, m10 ), dot( m02, m11 ), dot( m02, m12 )
              );
  return R;
}

mat3 transpose(mat3 inMatrix) {
  vec3 i0 = inMatrix[0];
  vec3 i1 = inMatrix[1];
  vec3 i2 = inMatrix[2];

  mat3 outMatrix = mat3(
      vec3(i0.x, i1.x, i2.x),
      vec3(i0.y, i1.y, i2.y),
      vec3(i0.z, i1.z, i2.z)
      );
  return outMatrix;
}

CameraMatrix getCameraMatrix(vec3 targetCameraPosition, vec3 targetCameraPoint)
{
  CameraMatrix cameraMatrix;
  vec3 vx0 = vec3( 1., 0., 0.);
  vec3 vy0 = vec3( 0., 1., 0.);
  vec3 vz0 = vec3( 0., 0., 1.);
  vec3 vz1 = normalize(targetCameraPoint-targetCameraPosition);
  vec3 vx1 = normalize(cross(vec3(0., 1., 0.), vz1));
  vec3 vy1 = cross(vz1, vx1);

  mat3 R = getRotateMatrixByAxe( mat3(vx0, vy0, vz0), mat3(vx1, vy1, vz1) );

  vec3 Rc = targetCameraPosition*transpose(R);

  cameraMatrix.m = mat4(
    vec4(vec3(R[0].x, R[1].x, R[2].x), -Rc.x), 
    vec4(vec3(R[0].y, R[1].y, R[2].y), -Rc.y), 
    vec4(vec3(R[0].z, R[1].z, R[2].z), -Rc.z), 
    vec4(vec3(    0.,     0.,     0.),    1.)  
    );
  cameraMatrix.mt = mat4(
    vec4(R[0], targetCameraPosition.x),
    vec4(R[1], targetCameraPosition.y),
    vec4(R[2], targetCameraPosition.z),
    vec4(vec3(0.),1.)  
    );
  return cameraMatrix;
}

float vec4tofloat(vec4 v0, float scale)
{
  float textureScale = 256.;
  vec4 v=v0*textureScale;
  float sign=1.;
  if(v.r>=10.)
  {
    sign=-1.;
    v.r = 0.;
  }
  float a = float(v.r)*65536.+float(v.g)*256.+float(v.b)+float(v.a)/256.;
  return sign*a/scale;
}

ImageCoordinate getImagePosition( vec3 point3D, vec2 sourceCentroid, float maxRadius, vec4 sourceMatrixVec0, vec4 sourceMatrixVec1, vec4 sourceMatrixVec2, vec2 imageSize, float zsign) 
{
  ImageCoordinate imageCoordinate;
  vec2 point2D;
  float px = dot(sourceMatrixVec0,vec4(vec3(point3D),1.));
  float py = dot(sourceMatrixVec1,vec4(vec3(point3D),1.));
  float pz = dot(sourceMatrixVec2,vec4(vec3(point3D),1.));


  point2D = vec2( px/pz, py/pz);

  vec2 sourceDiff = point2D-imageSize/2.;

  float sd = sqrt(dot(sourceDiff, sourceDiff));
  float td = atan(sd/maxRadius)*maxRadius;
  float scale = td/sd;

  point2D = sourceCentroid+sourceDiff*scale;

  if(pz*zsign>0. && point2D.x>=0. && point2D.x < imageSize.x && point2D.y>=0. && point2D.y < imageSize.y )
  {
    imageCoordinate.valid = true;
    imageCoordinate.imageCoord = point2D/imageSize;
    imageCoordinate.imageCoord.y = 1.-imageCoordinate.imageCoord.y;
  }
  else
  {
    imageCoordinate.valid = false;
  }

  return imageCoordinate;
}

void calcuateLight( out vec3 p, in vec2 p0)
{
  p=vec3(p0, 1.);
}

void main() {

  CameraMatrix cameraMatrix;
  cameraMatrix = getCameraMatrix( targetCameraPosition, targetCameraPoint);

  vec2 imageUV = v_texCoord.xy;

  imageUV += 1.;
  imageUV /= 2.;
  if(drawPlane>.5)
  {
    imageUV.y = 1.-imageUV.y;

    vec2 imageCoord = imageUV*outputResolution;

    vec4 r0 = vec4(vec3(0.), 1.);
    vec4 rv = vec4(imageCoord.x-outputResolution.x/2., imageCoord.y-outputResolution.y/2., targetCameraFocusLen, 0.);
    vec3 wr0 = (r0*cameraMatrix.mt).xyz;
    vec3 wrv = (rv*cameraMatrix.mt).xyz;

    Ray ray = Ray(wr0, wrv);
    Plane plane = Plane(worldPlanePoint, worldPlaneVector);
    IntersectPoints ppts = getIntersectRayPlane( ray, plane);
    if( ppts.count<=0)
    {
      gl_FragColor = vec4(vec3(0.),1.);
      return;
    }

    float world3DPointX = ppts.points0.x;
    float world3DPointY = ppts.points0.y;
    float world3DPointZ = ppts.points0.z;

    vec3 point3D = vec3(world3DPointX, world3DPointX, world3DPointX);
   
    float pixCount = 0.;
    vec3  colorVolume = vec3(0.);
    ImageCoordinate imageCoordinate;
    // front 
    if( frontValid >.5)
    {
      imageCoordinate  = getImagePosition(vec3(world3DPointX, world3DPointY, world3DPointZ), frontCetroid, frontMaxRadius, frontMatrixVec0, frontMatrixVec1, frontMatrixVec2, inputResolution, 1.);
      if( imageCoordinate.valid)
      {
        pixCount+=1.;
        vec2 pos = imageCoordinate.imageCoord;
        pos/=2.;
        pos+=vec2(.0,.5);
        vec4 color = texture2D( textureSource, pos );
        colorVolume+=color.rgb;
      }
    }

    // rear 
    if(  rearValid >.5)
    {
      imageCoordinate  = getImagePosition(vec3(world3DPointX, world3DPointY, world3DPointZ), rearCetroid, rearMaxRadius, rearMatrixVec0, rearMatrixVec1, rearMatrixVec2, inputResolution, -1.);
      if( imageCoordinate.valid)
      {
        pixCount+=1.;
        vec2 pos = imageCoordinate.imageCoord;
        pos/=2.;
        pos+=vec2(.5,.5);
        vec4 color = texture2D( textureSource, pos );
        colorVolume+=color.rgb;
      }
    }

    // left
    if(  leftValid >.5)
    {
      imageCoordinate  = getImagePosition(vec3(world3DPointX, world3DPointY, world3DPointZ), leftCetroid, leftMaxRadius, leftMatrixVec0, leftMatrixVec1, leftMatrixVec2, inputResolution, 1.);
      if( imageCoordinate.valid)
      {
        pixCount+=1.;
        vec2 pos = imageCoordinate.imageCoord;
        pos/=2.;
        pos+=vec2(.0,.0);
        vec4 color = texture2D( textureSource, pos );
        colorVolume+=color.rgb;
      }
    }

    // right
    if( rightValid >.5)
    {
      imageCoordinate  = getImagePosition(vec3(world3DPointX, world3DPointY, world3DPointZ), rightCetroid, rightMaxRadius, rightMatrixVec0, rightMatrixVec1, rightMatrixVec2, inputResolution, 1.);
      if( imageCoordinate.valid)
      {
        pixCount+=1.;
        vec2 pos = imageCoordinate.imageCoord;
        pos/=2.;
        pos+=vec2(.5,.0);
        vec4 color = texture2D( textureSource, pos );
        colorVolume+=color.rgb;
      }
    }

    if (pixCount>.5)
    {
      gl_FragColor = vec4(colorVolume/pixCount,1.);
    }
    else
    {
      gl_FragColor = BLACKCOLOR;
    }

  }
  else
  {


    gl_FragColor = texture2D(textureSource, imageUV);

  }

}

</script>


<script>

var camera, scene, renderer;
var stats;

var material;
var mesh;

var uniforms;

var loading=true;

var cameraAngel = 0;

var sourceBigImage;

init0();

function init0() {
  console.log(' lodding begin ' );

  sourceBigImage = THREE.ImageUtils.loadTexture('imgs/imageBig.png');
  console.log(' lodding end ' );


  THREE.DefaultLoadingManager.onProgress = function ( item, loaded, total ) {
        console.log( item, loaded, total );
        if(loaded == total)
        {
          var div = document.getElementById('loading');
          if (div) {
                div.parentNode.removeChild(div);
          }

          loading=false;
          init();
          animate();
        }
  };
}

function init(){




  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );




  //camera 

  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000000 );
  camera.position.z = 400;

  // stats
  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.left = '0px';
  stats.domElement.style.top = '0px';
  document.body.appendChild( stats.domElement );


  // control

  var imageWidth  = 720;
  var imageHeight = 576;

  var outputWidth = 720;
  var outputHeight= 480;


  // world

  scene = new THREE.Scene();

  var geometry = new THREE.PlaneGeometry( imageWidth, imageHeight, 1, 1 );


  uniforms = {
      inputResolution:  { type: "v2", value: new THREE.Vector2(imageWidth, imageHeight) },
      outputResolution: { type: "v2", value: new THREE.Vector2(outputWidth, outputHeight) },

       drawPlane: { type: "f", value:1 },
      frontValid: { type: "f", value:1 },
       rearValid: { type: "f", value:1 },
       leftValid: { type: "f", value:1 },
      rightValid: { type: "f", value:1 },

      targetCameraPosition: { type: "v3", value: new THREE.Vector3(-20000, -25000, 10000)},
      targetCameraPoint   : { type: "v3", value: new THREE.Vector3(-10000,      0,-35000)},
      targetCameraFocusLen: { type: 'f',  value: 341.1732   },


      worldPlanePoint     : { type: "v3", value: new THREE.Vector3(0, 0, 0)},
      worldPlaneVector    : { type: "v3", value: new THREE.Vector3(0, 1, 0)},

      textureSource: { type: "t", value: sourceBigImage},


      // textureWorldPointX: { type: "t", value: THREE.ImageUtils.loadTexture('imgs/world3DPointX.png') },
      // textureWorldPointY: { type: "t", value: THREE.ImageUtils.loadTexture('imgs/world3DPointY.png') },
      // textureWorldPointZ: { type: "t", value: THREE.ImageUtils.loadTexture('imgs/world3DPointZ.png') },
      // textureTT         : { type: "t", value: THREE.ImageUtils.loadTexture('imgs/tt.png'           ) },

      frontMaxRadius: { type: 'f', value: 202.2 },
       rearMaxRadius: { type: 'f', value: 208   },
       leftMaxRadius: { type: 'f', value: 213.2 },
      rightMaxRadius: { type: 'f', value: 204   },

      frontCetroid: { type: "v2", value: new THREE.Vector2(       394.63321888 ,       293.44220026  ) }, 
      rearCetroid: { type: "v2", value: new THREE.Vector2(       355.79253397 ,       294.78974697  ) }, 
      leftCetroid: { type: "v2", value: new THREE.Vector2(       360.97505420 ,       266.62506959  ) }, 
      rightCetroid: { type: "v2", value: new THREE.Vector2(       347.23003594 ,       280.26029983  ) }, 

      frontMatrixVec0:{type: "v4", value: new THREE.Vector4(      257.19585822,        87.43320690,       326.84292391,   3114364.04886467)},
      frontMatrixVec1:{type: "v4", value: new THREE.Vector4(       19.31716670,       292.19591761,       164.76435154,   3719472.77985118)},
      frontMatrixVec2:{type: "v4", value: new THREE.Vector4(        0.09324355,         0.29932670,         0.94958368,      9310.65902100)},

      rearMatrixVec0:{type: "v4", value: new THREE.Vector4(      212.86561552,      -284.57647977,       224.14651147,   8377347.81765448)},
      rearMatrixVec1:{type: "v4", value: new THREE.Vector4(       -3.81581805,      -360.85353105,        -9.33877620,  -4463128.91456287)},
      rearMatrixVec2:{type: "v4", value: new THREE.Vector4(       -0.01039541,        -0.79163816,         0.61090176,     21916.43167191)},

      leftMatrixVec0:{type: "v4", value: new THREE.Vector4(     -141.67322640,       330.77013760,       263.42218841,   8196871.30874001)},
      leftMatrixVec1:{type: "v4", value: new THREE.Vector4(       74.72380353,       381.08291844,       -39.22536686,   4087799.86151250)},
      leftMatrixVec2:{type: "v4", value: new THREE.Vector4(       -0.53865966,         0.84230286,         0.01927823,      5048.33549136)},

      rightMatrixVec0:{type: "v4", value: new THREE.Vector4(      178.51010800,       313.41971953,      -229.50470172,  -3401593.69887749)},
      rightMatrixVec1:{type: "v4", value: new THREE.Vector4(      -61.65523050,       364.42869434,        22.18754020,   5081778.15835737)},
      rightMatrixVec2:{type: "v4", value: new THREE.Vector4(        0.51743597,         0.85571837,         0.00246714,      4460.77443487)},



    };



  var material = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: document.getElementById( 'vertexShader' ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    } );


  mesh = new THREE.Mesh( geometry, material );
  scene.add( mesh );

  //
  initGUI(uniforms);

  window.addEventListener( 'resize', onWindowResize, false );


}


function initGUI(ob) {

  var gui = new dat.GUI();

  var API = {
    'draw at plane' : ob['drawPlane'].value >.5 ,

    'front valid' : ob['frontValid'].value >.5  ,
    ' rear valid' : ob[ 'rearValid'].value >.5  ,
    ' left valid' : ob[ 'leftValid'].value >.5  ,
    'right valid' : ob['rightValid'].value >.5  ,
  };


  gui.add( API, 'draw at plane' ).onChange( function() { ob['drawPlane'].value = 1-ob['drawPlane'].value; } );

  gui.add( API, 'front valid' ).onChange( function() { ob['frontValid'].value = 1-ob['frontValid'].value; } );
  gui.add( API, ' rear valid' ).onChange( function() { ob[ 'rearValid'].value = 1-ob[ 'rearValid'].value; } );
  gui.add( API, ' left valid' ).onChange( function() { ob[ 'leftValid'].value = 1-ob[ 'leftValid'].value; } );
  gui.add( API, 'right valid' ).onChange( function() { ob['rightValid'].value = 1-ob['rightValid'].value; } );

}

function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );

  render();

}

function animate() {

  requestAnimationFrame( animate );

  cameraAngel+=.01;
  // change the camera angel

  var rotateAngle=46097.7222864644;

  if(uniforms)
  {

  uniforms['targetCameraPosition'].value.x=uniforms['targetCameraPoint'].value.x+rotateAngle*Math.cos(cameraAngel);
  uniforms['targetCameraPosition'].value.z=uniforms['targetCameraPoint'].value.z+rotateAngle*Math.sin(cameraAngel);
  }

  if(renderer)
  renderer.render( scene, camera );
  if(stats)
  stats.update();

}

function render() {

  renderer.render( scene, camera );

}

</script>

<div id='loading'>
<h1>
loading...
</h1>
</div>

</body>
</html>

