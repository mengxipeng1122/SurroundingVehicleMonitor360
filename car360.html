<!DOCTYPE html>
<html lang="en">
<head>
<title>three.js webgl - geometry - cube</title>
<meta charset="utf-8">
<style>
body {
margin: 0px;
        background-color: #000000;
overflow: hidden;
}
</style>
</head>
<body>

<script src="refer/three.js/build/three.min.js"></script>
<script src="refer/three.js/examples/js/controls/TrackballControls.js"></script>
<script src="refer/three.js/examples/js/Detector.js"></script>
<script src="refer/three.js/examples/js/libs/stats.min.js"></script>
<script src="refer/three.js/examples/js/libs/dat.gui.min.js"></script>

<script id="vertexShader" type="x-shader/x-vertex">

varying vec3 v_texCoord;

uniform float drawPlane;

void main() {

  if(drawPlane>.5)
  {

    gl_Position = vec4( position, 1.0 );

  }
  else
  {
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }

  v_texCoord = position;


}

</script>

<script id="fragmentShader" type="x-shader/x-fragment">

uniform vec2 resolution;

uniform sampler2D textureFront;

uniform float drawPlane;

varying vec3 v_texCoord;

void main() {

   // gl_FragColor =vec4(vec3( drawPlane),1.);

  //return ;

  if(drawPlane>.5)
  {

    vec2 imageUV = v_texCoord.xy;

    imageUV += 1.;
    imageUV /= 2.;

    gl_FragColor = texture2D(textureFront, imageUV);

  }
  else
  {

    vec2 imageUV = v_texCoord.xy;

    imageUV += resolution/2.;

    vec2 vUv = vec2(imageUV.x/resolution.x, imageUV.y/resolution.y);
    gl_FragColor = texture2D(textureFront, vUv);

  }

}

</script>


<script>

var camera, scene, controls, renderer;

var material;
var mesh;

var uniforms;

init();
animate();

function init() {

  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  document.body.appendChild( renderer.domElement );

  //camera 

  camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000000 );
  camera.position.z = 400;


  // control
  controls = new THREE.TrackballControls( camera );

  controls.rotateSpeed = 1.0;
  controls.zoomSpeed = 1.2;
  controls.panSpeed = 0.8;

  controls.noZoom = false;
  controls.noPan = false;

  controls.staticMoving = true;
  controls.dynamicDampingFactor = 0.3;

  controls.keys = [ 65, 83, 68 ];

  controls.addEventListener( 'change', render );

  var imageWidth  = 720;
  var imageHeight = 576;


  // world

  scene = new THREE.Scene();
  // scene.matrixAutoUpdate=false;

  var geometry = new THREE.PlaneGeometry( imageWidth, imageHeight, 1, 1 );

  //var texture = THREE.ImageUtils.loadTexture( 'textures/crate.gif' );
  // var texture = THREE.ImageUtils.loadTexture( 'imgs/q.jpg');
  // texture.anisotropy = renderer.getMaxAnisotropy();

  //var material = new THREE.MeshBasicMaterial( { map: texture } );
  //var material = new THREE.MeshBasicMaterial( { } );

  var textureFront = THREE.ImageUtils.loadTexture( 'imgs/q.jpg');

  uniforms = {
      resolution: { type: "v2", value: new THREE.Vector2(imageWidth, imageHeight) },
      drawPlane: { type: "f", value:1 },
      textureFront: { type: "t", value: textureFront}
    };


  //setupControls(uniforms);

  var material = new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: document.getElementById( 'vertexShader' ).textContent,
      fragmentShader: document.getElementById( 'fragmentShader' ).textContent
    } );


  mesh = new THREE.Mesh( geometry, material );
  //mesh = new THREE.Mesh( geometry, null );
  scene.add( mesh );

  //


  initGUI(uniforms);

  window.addEventListener( 'resize', onWindowResize, false );

}


function setupControls(ob) {
  var gui = new dat.GUI();
  // var sceneFolder = gui.addFolder('Scene');
  // var geoController = sceneFolder.add({Geometry:"box"}, 'Geometry', [ 'box', 'sphere', 'torusknot' ] );
  //geoController.onChange(changeGeometry);
  var uniformsFolder = gui.addFolder('Uniforms');
  for(key in ob){
    if(ob[key].type == 'f'){
      var controller = uniformsFolder.add(ob[key], 'value').name(key);
      if(typeof ob[key].min != 'undefined'){
        controller.min(ob[key].min).name(key);
      }
      if(typeof ob[key].max != 'undefined'){
        controller.max(ob[key].max).name(key);
      }
      controller.onChange(function(value){
          this.object.value = parseFloat(value);
          });
    }else if(ob[key].type == 'c'){
      ob[key].guivalue = [ob[key].value.r * 255, ob[key].value.g * 255, ob[key].value.b * 255];
      var controller = uniformsFolder.addColor(ob[key], 'guivalue').name(key);
      controller.onChange(function(value){
          this.object.value.setRGB(value[0]/255, value[1]/255, value[2]/255);
          });
    }
  }
  uniformsFolder.open();
  //var sourceFolder = gui.addFolder('Source');
  //var butob = {
  //  'view vertex shader code': function(){
  //    TINY.box.show({html:'<div style="width: 500px; height: 500px;"><h3 style="margin: 0px; padding-bottom: 5px;">Vertex Shader</h3><pre style="overflow: scroll; height: 470px;">'+document.getElementById('vertexShader').text+'</pre></div>',animate:false,close:false,top:5})
  //  },
  //  'view fragment shader code': function(){
  //    TINY.box.show({html:'<div style="width: 500px; height: 500px;"><h3 style="margin: 0px; padding-bottom: 5px;">Fragment Shader</h3><pre style="overflow: scroll; height: 470px;">'+document.getElementById('fragmentShader').text+'</pre></div>',animate:false,close:false,top:5})
  //  }
  //};
  //sourceFolder.add(butob, 'view vertex shader code');
  //sourceFolder.add(butob, 'view fragment shader code');

}

function initGUI(ob) {

  var API = {
    'draw at plane' : ob['drawPlane'].value >.5
  };

  var gui = new dat.GUI();

  //gui.add( API, 'show model' ).onChange( function() { mesh.visible = API[ 'show model' ]; } );

  gui.add( API, 'draw at plane' ).onChange( function() {
    var oldValue = ob['drawPlane'].value;
    if (oldValue>.5)
    {
       ob['drawPlane'].value = 0.;
    }
    else
    {
       ob['drawPlane'].value = 1.;
    }
  } );

}

function onWindowResize() {

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

  renderer.setSize( window.innerWidth, window.innerHeight );

  controls.handleResize();
  render();

}

function animate() {
 
     requestAnimationFrame( animate );
 
 //  mesh.rotation.x += 0.00;
 //  mesh.rotation.y += .01;
 //  mesh.rotation.z += 0.00;
 
   renderer.render( scene, camera );
 
   controls.update();
 }

function render() {

  renderer.render( scene, camera );

}

</script>

</body>
</html>

